<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Java Code Viewer</title>

    <style>
        body {
            font-family: Arial, sans-serif;
            background: #f4f6f8;
            padding: 30px;
        }

        h1 {
            color: #333;
        }

        .code-container {
            background: #1e1e1e;
            color: #dcdcdc;
            padding: 20px;
            border-radius: 6px;
            position: relative;
            overflow-x: auto;
        }

        pre {
            margin: 0;
            white-space: pre;
        }

        .copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #4caf50;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
        }

        .copy-btn:hover {
            background: #43a047;
        }

        textarea {
            width: 100%;
            height: 200px;
            margin-top: 20px;
            font-family: monospace;
            font-size: 14px;
            padding: 10px;
        }

        .update-btn {
            margin-top: 10px;
            padding: 8px 16px;
            cursor: pointer;
        }
    </style>
</head>
<body>

<h1>Java Code Viewer</h1>

<div class="code-container">
    <button class="copy-btn" onclick="copyCode()">Copy</button>
    <pre><code id="codeBlock"></code></pre>
</div>
<h3>Edit Java Code (optional)</h3>
<textarea id="codeEditor"></textarea>
<br>
<button class="update-btn" onclick="updateCode()">Update Code</button>
<script>
    // ðŸ”¹ Put your Java code here (easy to update) 
    let javaCode = `// ---------------- REPORT 
    
â¸»

1. Description

Trades received from Tadawul were missing key CCP fields such as Settlement ID and other related identifiers.
Only the T message was received, and the CCP QMD SI information was not available for the trades.

Additionally, the Trade Report AE message was not received due to a FIXML issue from Tadawul.
Because of this, required settlement-related data was not populated in our system.

â¸»

2. Business Impact

If the missing settlement details are not updated:
	â€¢	Trade confirmations will be generated with incorrect or incomplete settlement information.
	â€¢	This will directly impact the settlement process.
	â€¢	There is a risk of settlement failures and reconciliation issues.

This is a business-critical issue caused by the external Tadawul message problem.

â¸»

3. Short Description

Missing CCP settlement fields in trades due to FIXML message issue from Tadawul.
Manual database update required to populate missing settlement information.

â¸»

4. Implementation Plan
	1.	Identify affected trades where CCP settlement fields are missing.
	2.	Take business approval for manual correction.
	3.	Update the required settlement fields in the database for affected trades.
	4.	Verify data consistency after the update.

â¸»

5. Technical Impact
	â€¢	Direct database update on trade records to populate missing CCP settlement fields.
	â€¢	No application deployment or code changes required.
	â€¢	Changes limited only to affected trades.

â¸»

6. Post-Implementation Verification Plan
	1.	Verify that all affected trades have the correct settlement IDs and CCP fields.
	2.	Re-generate or validate trade confirmations.
	3.	Confirm settlement details are correctly reflected in downstream systems.
	4.	Obtain business confirmation that trades are correct
    
    package com.report.test;

import java.io.File;
import java.io.FileInputStream;
import java.util.*;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

public class StaticDataLoader {

    // Required columns
    private static final String[] REQUIRED_COLUMNS = {
        "BATCH_ID",
        "OFFER_CODE",
        "HARD_CODE",
        "START_COUNTER"
    };

    public static Map<String, String> load(File file) throws Exception {

        if (file == null || !file.exists()) {
            throw new RuntimeException("Static file not found: " + file);
        }

        System.out.println("Loading static data: " + file.getName());

        Map<String, String> map = new LinkedHashMap<>();

        try (FileInputStream fis = new FileInputStream(file);
             Workbook wb = new XSSFWorkbook(fis)) {

            Sheet sheet = wb.getSheetAt(0);

            if (sheet == null) {
                throw new RuntimeException("Static file has no sheet");
            }

            Row headerRow = sheet.getRow(0);
            Row valueRow = sheet.getRow(1);

            if (headerRow == null) {
                throw new RuntimeException("Static file missing header row");
            }

            if (valueRow == null) {
                throw new RuntimeException("Static file missing data row");
            }

            DataFormatter formatter = new DataFormatter();
            int lastCol = headerRow.getLastCellNum();

            for (int i = 0; i < lastCol; i++) {
                Cell headerCell = headerRow.getCell(i, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK);
                Cell valueCell = valueRow.getCell(i, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK);

                String key = formatter.formatCellValue(headerCell).trim();
                String value = formatter.formatCellValue(valueCell).trim();

                if (!key.isEmpty()) {
                    map.put(key, value);
                }
            }

            // Validate required columns
            validateRequiredColumns(map);
        }

        System.out.println("Static fields loaded: " + map);
        return map;
    }

    private static void validateRequiredColumns(Map<String, String> map) {

        List<String> missingColumns = new ArrayList<>();
        List<String> emptyValues = new ArrayList<>();

        for (String col : REQUIRED_COLUMNS) {

            if (!map.containsKey(col)) {
                missingColumns.add(col);
            } else if (map.get(col) == null || map.get(col).trim().isEmpty()) {
                emptyValues.add(col);
            }
        }

        if (!missingColumns.isEmpty()) {
            throw new RuntimeException(
                "Missing required static columns: " + missingColumns);
        }

        if (!emptyValues.isEmpty()) {
            throw new RuntimeException(
                "Static columns have empty values: " + emptyValues);
        }
    }
}
    
    
    
    
    
    @echo off
echo ===============================
echo IPO Subscription Tool Started
echo ===============================

java -jar IpoSubscriptionTool.jar

echo.
echo Process finished.
pause
    
    private static void validateFileDate(String fileName) {
    String todayDate = new SimpleDateFormat("yyyyMMdd").format(new Date());

    String[] parts = fileName.split("-");

    if (parts.length < 5) {
        throw new RuntimeException("Invalid dynamic file name format: " + fileName);
    }

    String fileDate = parts[3];

    if (!todayDate.equals(fileDate)) {
        throw new RuntimeException(
            "Dynamic file is old. Expected: " + todayDate +
            ", found: " + fileDate
        );
    }
}

public static void main(String[] args) {

    try {
        System.out.println("Report Generator Started");

        File staticFile = new File("input/static.xlsx");

        if (!staticFile.exists()) {
            throw new RuntimeException("Static file not found. Check: input/static.xlsx");
        }

        Map<String, String> staticFields = StaticDataLoader.load(staticFile);

        if (staticFields == null || staticFields.isEmpty()) {
            throw new RuntimeException("Static file has no data");
        }

        String latestFileName = latestFile(
                staticFields.get("OFFER_CODE"),
                staticFields.get("HARD_CODE")
        );

        if (latestFileName == null) {
            throw new RuntimeException("No matching dynamic file found in input folder");
        }

        File dynamicFile = new File("input/" + latestFileName);

        if (!dynamicFile.exists()) {
            throw new RuntimeException("Dynamic file not found: " + latestFileName);
        }

        int lastDot = latestFileName.lastIndexOf('.');
        File outputFile = new File("output/"
                + latestFileName.substring(0, lastDot) + ".sub");

        List<Map<String, String>> dynamicRows =
                IpoDataExcelReader.read(dynamicFile);

        if (dynamicRows == null || dynamicRows.isEmpty()) {
            throw new RuntimeException("Dynamic file has no data");
        }

        // WRITE OUTPUT
        SubFileWriter.write(outputFile, staticFields, dynamicRows);

        System.out.println("Report Generator Completed");
        System.out.println("OUTPUT File: " + outputFile.getAbsolutePath());

    } catch (Exception e) {
        System.out.println("ERROR: " + e.getMessage());
        e.printStackTrace();
    }
}
            
    // ---------------- STATIC LOADER ----------------
    package com.report.test;

import java.io.File;
import java.io.FileInputStream;
import java.util.LinkedHashMap;
import java.util.Map;

import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

public class StaticDataLoader {

    public static Map<String, String> load(File file) throws Exception {
        System.out.println("Loading static data: " + file.getName());

        Map<String, String> map = new LinkedHashMap<>();

        try (FileInputStream fis = new FileInputStream(file);
             Workbook wb = new XSSFWorkbook(fis)) {

            Sheet sheet = wb.getSheetAt(0);

            Row headerRow = sheet.getRow(0);
            Row valueRow = sheet.getRow(1);

            if (headerRow == null || valueRow == null) {
                throw new RuntimeException("Static file must have header and one data row");
            }

            DataFormatter formatter = new DataFormatter();

            for (int i = 0; i < headerRow.getLastCellNum(); i++) {
                Cell headerCell = headerRow.getCell(i);
                Cell valueCell = valueRow.getCell(i);

                if (headerCell == null) continue;

                String key = formatter.formatCellValue(headerCell).trim();
                if (key.isEmpty()) continue;

                String value = "";
                if (valueCell != null) {
                    value = formatter.formatCellValue(valueCell).trim();
                }

                map.put(key, value);
            }
        }

        System.out.println("Static map: " + map);
        return map;
    }
}
    // ---------------- DYNAMIC DATA READER ----------------
     
package com.report.test;

import java.io.File;
import java.io.FileInputStream;
import java.util.*;

import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

public class DataExcelReader {

    public static List<Map<String, String>> read(File dataFile) throws Exception {
        List<Map<String, String>> rows = new ArrayList<>();

        try (FileInputStream fis = new FileInputStream(dataFile);
             Workbook wb = new XSSFWorkbook(fis)) {

            Sheet sheet = wb.getSheetAt(0);
            Row headerRow = sheet.getRow(0);

            if (headerRow == null) {
                throw new RuntimeException("Dynamic file has no header row");
            }

            DataFormatter formatter = new DataFormatter();

            int lastCol = headerRow.getLastCellNum();

            List<String> headers = new ArrayList<>();

            // Build headers
            for (int i = 0; i < lastCol; i++) {
                Cell c = headerRow.getCell(i, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK);
                String name = formatter.formatCellValue(c).trim();

                if (name.isEmpty()) {
                    name = "COL_" + (i + 1); // generate safe name
                }

                headers.add(name);
            }

            // Read data rows
            for (int i = 1; i <= sheet.getLastRowNum(); i++) {
                Row r = sheet.getRow(i);
                if (r == null) continue;

                Map<String, String> row = new LinkedHashMap<>();
                boolean hasData = false;

                for (int j = 0; j < headers.size(); j++) {
                    Cell c = r.getCell(j, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK);
                    String value = formatter.formatCellValue(c).trim();

                    if (!value.isEmpty()) {
                        hasData = true;
                    }

                    row.put(headers.get(j), value);
                }

                if (hasData) {
                    rows.add(row);
                }
            }
        }

        return rows;
    }
}
    // ---------------- NUMBER GENERATOR ----------------
    static class NumberGenerator {

        private long counter;
        private final String prefix;

        public NumberGenerator(String prefix, long counter) {
            this.prefix = prefix;
            this.counter = counter;
        }

        public String next() {
            return prefix + String.format("%07d", counter++);
        }
    }

    // ---------------- OUTPUT WRITER ----------------
     
`;

    // Load code on page load
    document.getElementById("codeBlock").textContent = javaCode;
    document.getElementById("codeEditor").value = javaCode;

    function updateCode() {
        javaCode = document.getElementById("codeEditor").value;
        document.getElementById("codeBlock").textContent = javaCode;
    }

    function copyCode() {
        navigator.clipboard.writeText(javaCode);
        
    }
</script>

</body>
</html>
